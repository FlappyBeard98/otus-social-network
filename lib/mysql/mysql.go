// Package mysql provides a set of functions to work with mysql database
package mysql

import (
	"context"
	"database/sql"
	"fmt"

	"github.com/georgysavva/scany/v2/sqlscan"
	_ "github.com/go-sql-driver/mysql"
	_ "github.com/golang-migrate/migrate/v4"
	_ "github.com/golang-migrate/migrate/v4/database/mysql"
	_ "github.com/golang-migrate/migrate/v4/source/file"
	_ "github.com/ilyakaznacheev/cleanenv"
)

// SqlQuery is a wrapper for sql query with params
type SqlQuery struct {
	sql    string
	params []any
}

// NewSqlQuery creates new SqlQuery
func NewSqlQuery(sql string, params ...any) *SqlQuery {
	return &SqlQuery{sql: sql, params: params}
}

// QueryOne executes query and scans one row into dst
func (o *SqlQuery) QueryOne(ctx context.Context, db Db, dst any) error {
	rows, err := db.QueryContext(ctx, o.sql, o.params...)
	if err != nil {
		return fmt.Errorf("scany: query multiple result rows: %w", err)
	}
	if err := sqlscan.ScanOne(dst, rows); err != nil {
		return fmt.Errorf("scanning one: %w", err)
	}
	return nil
}

// Query executes query and scans all rows into dst
func (o *SqlQuery) Query(ctx context.Context, db Db, dst any) error {
	err := sqlscan.Select(ctx, db, dst, o.sql, o.params...)

	return err
}

// Exec executes query and returns result
func (o *SqlQuery) Exec(ctx context.Context, db Db) (ExecResult, error) {
	result := ExecResult{}
	r, err := db.Exec(o.sql, o.params...)

	if err != nil {
		return result, err
	}

	if n, err := r.LastInsertId(); err != nil {
		result.LastInsertId = -1
	} else {
		result.LastInsertId = n
	}

	if n, err := r.RowsAffected(); err != nil {
		result.RowsAffected = -1
	} else {
		result.RowsAffected = n
	}

	return result, nil
}

// ExecResult is a result of Exec method
type ExecResult struct {
	LastInsertId int64 // LastInsertId returns the integer generated by the database in response to a command.
	RowsAffected int64 // RowsAffected returns the number of rows affected by an update, insert, or delete.
}

// Like prepares LIKE-statement for sql query
func Like(str *string, pre bool, post bool) *string {

	if str == nil {
		return nil
	}
	s := *str

	if pre {
		s = "%" + s
	}

	if post {
		s = s + "%"
	}

	return &s
}

// BeginTxFunc executes function in transaction
func BeginTxFunc(ctx context.Context, opts *sql.TxOptions, db *sql.DB, fn func(context.Context, *sql.Tx) error) error {

	tx, err := db.BeginTx(ctx, opts)

	if err != nil {
		return err
	}

	defer func() {
		if r := recover(); r != nil || err != nil {
			_ = tx.Rollback()
		} else {
			_ = tx.Commit()
		}
	}()

	err = fn(ctx, tx)

	if err != nil {
		return err
	}

	return nil
}

// Db is a wrapper for sql.DB
type Db interface {
	// Exec executes a query without returning any rows.
	Exec(query string, args ...any) (sql.Result, error)
	// ExecContext executes a query without returning any rows.
	Query(query string, args ...any) (*sql.Rows, error)
	// QueryRow executes a query that is expected to return at most one row.
	QueryRow(query string, args ...any) *sql.Row
	// QueryRowContext executes a query that is expected to return at most one row.
	QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
}

// DbConfig is a configuration for mysql connection
type DbConfig struct {
	ConnectionString string `json:"connectionString" env:"CONNECTION_STRING"` // ConnectionString is a connection string for mysql
}

// Connect connects to mysql database
func Connect(cfg DbConfig) (*sql.DB, error) {
	db, err := sql.Open("mysql", cfg.ConnectionString)

	if err != nil {
		return nil, err
	}

	if err = db.Ping(); err != nil {
		return nil, err
	}

	return db, nil
}
